/*
 * Copyright (C) 2022 l-m.dev
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#include "demos.h"
#include <ctype.h>
#include <string.h>
#include <time.h>

const char *hangman_words[] = {
	"algorithm",   "bytecode", "compiler", "debugging", "encryption",
	"firewall",	   "graphics", "hacker",   "input",		"javascript",
	"kernel",	   "loop",	   "malware",  "network",	"operating",
	"protocol",	   "queue",	   "robotics", "software",	"terminal",
	"unix",		   "virtual",  "web",	   "xml",		"yield",
	"zip",		   "assembly", "binary",   "cache",		"database",
	"ethernet",	   "firewire", "gigabyte", "hashing",	"interrupt",
	"java",		   "kernel",   "logic",	   "mainframe", "namespace",
	"output",	   "program",  "query",	   "router",	"storage",
	"transaction", "unicode",  "viewport", "wireless",	"xor",
};

const char *hangman_hints[] = {
	"A step-by-step problem-solving process.",
	"Low-level representation of code executed by a virtual machine.",
	"Translates high-level code into machine code.",
	"Finding and fixing errors in code.",
	"Converting data into a secret code to secure it.",
	"A barrier that prevents unauthorized access.",
	"Creating and manipulating visual images.",
	"An individual who breaks into computer systems.",
	"User input to a computer system.",
	"A scripting language commonly used for web development.",
	"The core component of an operating system.",
	"A sequence of instructions that repeats.",
	"Software designed to harm or exploit computer systems.",
	"A network of interconnected devices.",
	"Managing computer hardware and software resources.",
	"A set of rules for data communication.",
	"A data structure that follows the FIFO principle.",
	"The design and creation of robots.",
	"Instructions and data that tell a computer what to do.",
	"A text-based interface to interact with a computer.",
	"An operating system known for its multitasking capabilities.",
	"Simulated environment that is not physically present.",
	"A markup language for structuring and presenting content.",
	"To produce or provide a yield.",
	"A file compression format.",
	"Low-level programming language.",
	"Base-2 numeral system.",
	"High-speed data storage.",
	"Structured collection of data.",
	"A means of connecting devices to a network.",
	"High-speed data transfer interface.",
	"A unit of digital information.",
	"Converting data into a fixed-size string of characters.",
	"An event that interrupts normal processing.",
	"Object-oriented programming language.",
	"The core part of an operating system.",
	"A method of reasoning used in programming.",
	"A large, powerful computer used for complex tasks.",
	"A container for organizing code elements.",
	"Data generated by a program.",
	"A set of instructions executed by a computer.",
	"A request for information from a database.",
	"Directs data between networks.",
	"A place to store data or belongings.",
	"An exchange of information or currency.",
	"A character encoding standard.",
	"A visible area of a user interface.",
	"Communication without physical connections.",
	"A bitwise operation.",
};

EM_JS(int, random_of, (int of), {return Math.random() * (of - 1) | 0})

void hangman(void) {
	enum hangman_state {
		ST_FINE,
		ST_FAILED,
		ST_SUCCESS,
	};

	static enum hangman_state state = ST_FINE;

	switch (state) {
	case ST_FINE: break;
	case ST_FAILED:
		igPushStyleColor_U32(ImGuiCol_WindowBg, IM_COL32(255, 0, 0, 255));
		break;
	case ST_SUCCESS:
		igPushStyleColor_U32(ImGuiCol_WindowBg, IM_COL32(0, 255, 0, 255));
		break;
	}

	igSetNextWindowPos((ImVec2){10, 10}, ImGuiCond_Once, (ImVec2){0, 0});
	igSetNextWindowSize((ImVec2){400.f, 400.f}, ImGuiCond_Once);
	igBegin("Hangman", 0, ImGuiWindowFlags_NoResize);

	if (state != ST_FINE) {
		igPopStyleColor(1);
		state = ST_FINE;
	}

	bool refresh = false;

	static int word_idx = -1;
	static const char *selected_word;
	static unsigned selected_word_len = 0;
	static char selbuf[64];
	static unsigned found_chars;
	static char missed_letters[64];
	static unsigned missed_letters_count = 0;

	if (word_idx == -1) {
		// select random
		word_idx = random_of(IM_ARRAYSIZE(hangman_words));

		// initialise variables
		selected_word = hangman_words[word_idx];
		selected_word_len = strlen(selected_word);
		memset(selbuf, '_', selected_word_len);
		selbuf[selected_word_len] = 0;
		found_chars = 0;
		memset(missed_letters, 0, IM_ARRAYSIZE(missed_letters));
		missed_letters_count = 0;
	}

	ImGuiIO *io = igGetIO();

	if (found_chars != selected_word_len) {
		unsigned short ch = 0;
		// if there is characters, and the window is focused
		if (io->WantCaptureMouse && io->InputQueueCharacters.Size > 0) {
			ch = io->InputQueueCharacters.Data[0];
			if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
				ch = tolower(ch);
			} else {
				ch = 0;
			}
		}
		// if `ch` isn't nul && `ch` hasn't been found yet
		if (ch != 0 && !strchr(selbuf, ch)) {
			bool ever_found = false;

			for (unsigned i = 0; i < selected_word_len; i++) {
				if (selected_word[i] == ch) {
					// found
					selbuf[i] = ch;
					found_chars++;
					ever_found = true;
					state = ST_SUCCESS;
				}
			}
			// append to missed letters if never found and never missed before
			if (!ever_found && !strchr(missed_letters, ch)) {
				state = ST_FAILED;
				missed_letters[missed_letters_count++] = ch;
			}
		}
		igText("missed: %s", missed_letters);
	} else {
		igText("found!");
	}
	if (igButton("refresh everything", V2ZERO)) {
		refresh = true;
	}

	igTextWrapped("hint: %s", hangman_hints[word_idx]);
	igTextWrapped("%s", selbuf);

	if (refresh) {
		word_idx = -1;
	}

	igEnd();
}

void frame(void) {
	FRAME_PASS_BEGIN;

	hangman();

	BLIT_BG(IM_COL32(50, 50, 50, 255));

	igShowDemoWindow(false);

	FRAME_PASS_END;
}